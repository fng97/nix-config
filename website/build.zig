const std = @import("std");

pub fn build(b: *std.Build) !void {
    const host = b.graph.host.result;
    const target = b.resolveTargetQuery(.{}); // native
    const optimize = std.builtin.OptimizeMode.Debug;

    const website = b.addWriteFiles(); // output folder for website content
    _ = website.addCopyFile(b.path("styles.css"), "styles.css"); // copy in the style file

    // This step collates the list of blog posts, adds it (with links to the pages) to "index.html",
    // and generates the Atom feed. Its arguments are the Zig cache paths to:
    // - all of the blog post HTML files generated by Pandoc,
    // - the input "index.html" generated by Pandoc,
    // - the output "index.html" (where the final index will be written),
    // - and the output "atom.xml".
    const module = b.addModule("website_tools", .{
        .root_source_file = b.path("src/blog_list_builder.zig"),
        .target = target,
        .optimize = optimize,
    });
    const blog_list_builder = b.addExecutable(.{
        .name = "blog_list_builder",
        .root_module = module,
    });
    const build_blog_list_step = b.addRunArtifact(blog_list_builder);
    const updated_index = build_blog_list_step.addPrefixedOutputFileArg("--index-out=", "index.html");
    const atom_feed = build_blog_list_step.addPrefixedOutputFileArg("--feed=", "atom.xml");

    _ = website.addCopyFile(updated_index, "index.html"); // copy in the final "index.html"
    _ = website.addCopyFile(atom_feed, "atom.xml"); // copy in the generated feed

    // Process website content. Non-Markdown files are copied directly to the output. HTML is
    // generated from Markdown files using Pandoc.
    var dir = try std.fs.cwd().openDir("content", .{ .iterate = true });
    defer dir.close();
    var walker = try dir.walk(b.allocator);
    defer walker.deinit();
    while (try walker.next()) |entry| {
        if (entry.kind != .file) continue;

        const filepath = b.path(b.pathJoin(&.{ "content", entry.path }));
        const filename = entry.basename;

        // Copy in non-Markdown files (assets).
        if (!std.mem.endsWith(u8, entry.basename, ".md")) {
            _ = website.addCopyFile(filepath, entry.path); // preserve file structure
            continue;
        }

        // Blog posts start with the publication date and have the format "YYYYMMDD-*.md": eight
        // digits followed by a "-".
        const is_blog_post = filename.len >= 9 and filename[8] == '-' and starts_with_8_digits: {
            for (filename[0..8]) |c| if (!std.ascii.isDigit(c)) break :starts_with_8_digits false;
            break :starts_with_8_digits true;
        };

        // Create a Pandoc step for each Markdown file to generate HTML from the Markdown.
        const pandoc_step = std.Build.Step.Run.create(b, b.fmt("pandoc: {s}", .{filename}));
        pandoc_step.addArgs(&.{"pandoc"}); // dependency managed by Nix
        pandoc_step.addArgs(&.{
            "--from=markdown",
            "--to=html5",
            "--fail-if-warnings=true",
            "--shift-heading-level-by=1", // # -> ##
        });
        pandoc_step.addPrefixedFileArg("--template=", b.path("template.html"));
        pandoc_step.addPrefixedFileArg("--css=", b.path("styles.css"));
        pandoc_step.addPrefixedFileArg("--lua-filter=", b.path("pandoc/title-from-h1.lua"));
        pandoc_step.addPrefixedFileArg("--lua-filter=", b.path("pandoc/fix-md-links.lua"));
        if (is_blog_post) { // pass the publication date as metadata to Pandoc
            const year = filename[0..4]; // YYYY
            const month = filename[4..6]; // MM
            const day = filename[6..8]; // DD
            pandoc_step.addArg(b.fmt("--metadata=date:{s}-{s}-{s}", .{ year, month, day }));
        }
        pandoc_step.addFileArg(filepath);
        const generated_html_path = pandoc_step.captureStdOut();

        // Map "*.md" -> "*.html" (e.g. "index.md" -> "index.html").
        const html_filename = b.fmt("{s}.html", .{filename[0 .. filename.len - ".md".len]});

        if (std.mem.eql(u8, filename, "index.md")) {
            // Don't copy in "index.html". This step will save the final "index.html".
            build_blog_list_step.addPrefixedFileArg("--index-in=", generated_html_path);
            continue;
        }

        if (is_blog_post) build_blog_list_step.addPrefixedFileArg(
            b.fmt("--blog-post={s}:", .{html_filename}), // need the filename for the hyperlink
            generated_html_path,
        ); // e.g. "--blog-post=20250705-i-like-coffee.html:{zig-cache-path}/stdout"

        _ = website.addCopyFile(generated_html_path, html_filename); // copy in generated HTML
    }

    b.installDirectory(.{
        .source_dir = website.getDirectory(),
        .install_dir = .prefix,
        .install_subdir = ".",
    });

    const test_step = b.step("test", "Run tests");
    const test_options = b.addOptions();
    test_options.addOption([]const u8, "html_dir", b.getInstallPath(.prefix, ""));
    const tests_module = b.createModule(.{
        .root_source_file = b.path("src/checks.zig"),
        .target = target,
        .optimize = optimize,
    });
    const tests = b.addTest(.{ .root_module = tests_module });
    tests.root_module.addOptions("config", test_options);
    tests.step.dependOn(b.getInstallStep()); // make sure HTML installed to prefix before tests run
    const run_unit_tests = b.addRunArtifact(tests);
    test_step.dependOn(&run_unit_tests.step);

    // This step is used to "hot-reload" the web page as I'm working on it. I hook this up to a nvim
    // autocmd that runs on save.
    const reload_step = b.step("reload", "Open (or reload) the given page in the default browser.");
    const open_cmd = b.addSystemCommand(&.{ "open", "--background" });
    if (b.args) |a| open_cmd.addArgs(a) else open_cmd.step.dependOn(
        &b.addFail("'open' requires at least one argument").step,
    );
    if (host.os.tag != .macos) open_cmd.step.dependOn(&b.addFail("'open' is macOS-only").step);
    open_cmd.step.dependOn(b.getInstallStep());
    reload_step.dependOn(&open_cmd.step);

    // Add step for ZLS build-on-save.
    const module_check = b.addExecutable(.{ .name = "module_check", .root_module = module });
    const tests_check = b.addExecutable(.{ .name = "tests_check", .root_module = tests_module });
    const check = b.step("check", "ZLS compilation checks");
    check.dependOn(&module_check.step);
    check.dependOn(&tests_check.step);
}
